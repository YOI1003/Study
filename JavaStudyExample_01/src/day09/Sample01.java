package day09;

public class Sample01 {
	//재귀함수(Recursive Function)
	//함수 내부에서 자기 자신을 호출하는 함수를 의미합니다.
	//반복적인 호출 작업을 쉽게 설계할 수 있습니다.
	
	//유의사항 : 종료 조건을 제대로 안만들어 놓으면 계속 호출이 진행됩니다
	//		  함수는 호출을 하고 작업이 마무리 되면 제거하는 식으로 내부에서 처리가 되는데
	//		  제거하지 못하고 계속 호출만 발생하면 그 호출이 쌓이게 됩니다.(Call Stack)
	//		  더이상 저장하지 못해 프로그램이 문제생길 수 있어 자바에서는 너무 많은 호출 스택이 쌓이면
	//		  강제로 프로그램을 종료합니다.(Stack OverFlow)
	
	
	//장점: 코드의 가독성이 좋아집니다.
	//	   일부 알고리즘 구현 시 재귀함수를 사용하는 것이 더 쉽게 풀리는 경우가 있습니다.
	//재귀 식을 연습하면 특정 알고리즘 문제에 대한 풀이를 진행하기 좋습니다.
	
	//단점: 함수의 호출을 반복적으로 실행하는 설계이기에 일반적인 반복문보다 실행 속도가 느립니다.
	
	//	   재귀함수를 실전의 영역에서 사용한다면 다음과 같은 상황에는 나쁘지 않습니다.
	//	   1. 같은 로직을 계속해서 반복해야 하는 경우(단, 너무 큰 데이터가 아닌 경우)
	//	   2. 자료 구조 중 트리 형태의 구조 반복하는 경우
	//	   3. API에서 페이지 메뉴 변경과 같은 변경 빈도가 낮은 설계에서 효과적입니다.
	
	
	public static void MyTurn(int turnCount)
	{
		if(turnCount == 0) //1. 종료 조건
		{
			return;
		}
		else
		{
		System.out.println("제 턴입니다.  남은턴:" + (turnCount-1)); //2. 함수 호출 시 진행할 명령
		MyTurn(turnCount-1); //3. 종료 조건에 도달할 수 있는 자기 자신 호출
		}
	}
	//다음은 day08의 Sample02에서 다뤘던 최대공약수 함수를 재귀함수로 변경한 코드입니다.
	public static int GCD(int M, int N)
	{
		if(N == 0)
			return M;
		else
			return GCD(N, M % N);
	}
	//두 수에 대한 최대공약수는 큰 수를 작은 수로 나누어 떨어지게 하는 작업을 반복하여
	//나머지가 0이 될 때까지 반복합니다.이 과정에서 0이 나왔을 때의 작은 수가 최대 공약수
	
	//ex) GCD(12,8);
	//       GCD(8,4);
	//		   GCD(4,0); 작업 종료
	//		   따라서 최대공약수 = 4
	
	//유클리드 호제법
	//12 = 8 * 1 + 4;
	// 8 = 4 * 2 + 0;
	// 따라서 최대 공약수 = 4
	
	
	
	
	
//	public static void Binary(int I)
//	{
//		if(I > 1) //1하고 0은 나눠줄 필요가 없기 때문
//		{
//			Binary(I / 2); //2로 나눠준 몫으로 2진수를 계산합니다.
//		}
//		System.out.print(I % 2 + " "); //2로 나눈 나머지 값을 출력합니다.
//	}
	public static void Binary(int I)
	{
		if(I == 0)
			return;
		
		Binary(I/2);
		System.out.print(I%2);
	}
	
	
	public static int Factorial(int N)
	{
		if(N > 2)
			return N * Factorial(N-1);
		else
			return N;
	}
	//강사님 풀이
//	public int Factorial(int N)
//	{
//		//1. 종료 조건부터 설계합니다. 1부터 N까지의 합이기 때문에 N부터 시작해서 1에서 멈추게 되어 있음.
//		if(N == 1)
//			return 1;
//		return N * Factorial(N-1);
//		
//	}
	
	
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		MyTurn(5);
		//MyTurn(5) "제 턴입니다."
		// MyTurn(4) "제 턴입니다."
		//  MyTurn(3) "제 턴입니다."
		//   MyTurn(2) "제 턴입니다."
		//    MyTurn(1) "제 턴입니다."
		//     MyTurn(0) return;
		
		//문제: 다음 입력과 출력창을 보고 함수 Binary(int I); 를 설계하세요.
		//단, 입력은 따로 안합니다.
		
		Binary(8);
		//1 0 0 0
		
		
		//문제: 자연수 N에 대하여 1부터 N까지의 모든 자연수를 곱한 값을 계산하세요.
		//  	Factorial(int N)
		System.out.println("");
		System.out.println(Factorial(5)); //120
		
		
		//주머니에는 구슬 7개의 다른 구슬이 들어있습니다.
		//해당 구슬 중 3개를 뽑아서 일렬로 나열하는 방법의 수를 구하시오.
		
		//순열 문제(Permutation)
		//서로 다른 n개의 원소 중에서 r개를 뽑아서 나열하는 방법의 수
		//nPr = n * (n-1) * .... * (n - (r-1))
		
		//위의 문제를 순열로 하면 7P3
		
		//첫 번째 구슬을 꺼낼 경우의 수: 7
		//두 번째 구슬을 꺼낼 경우의 수: 6
		//세 번째 구슬을 꺼낼 경우의 수: 5
		//7 * 6 * 5 = 210(비복원추출: 꺼낸걸 다시 집어넣지 않겠다.)
		
		//7 * (7-1) * (7-2)
		
		//만약에 복원 추출(꺼낸걸 다시 집어넣는 경우)일 경우
		//7 * 7 * 7  n파이r
		
		
		//팩토리얼을 이용해서 7P3을 계산합니다.
		//ex) nPr = n! / (n-r)!
		
		//경우의 수를 뽑는 방법
		//	   전체 경우
		//%    부분 경우의 수
		//----------------
		
		System.out.printf("%dP%d = %d! / (%d - %d)! = %d! / %d = %d\n"
				,7,3,7,7,3,7,3,Factorial(7) / Factorial(4));
		
		
		//7개의 구슬 중에서 빨간 공이 3개 초록공이 2개 노란공이 2개라고 할때,
		// 이 구슬을 일렬로 나열하는 경우의 수를 출력하시오.
		
		
		//7!
		//3! * 2! * 2!
		
		//같은 것이 존재하는 순열 = n!
		//                   a! * b! * c! (a+b+c = n)
		
		
		
		//5명의 플레이어 A,B,C,D,E가 원탁에 둘러 앉아있습니다.
		//원탁에 둘러앉는 경우의 수?
		
		//전체 경우 -> 5!
		//부분 경우 -> 5(중복적인 부분)
		
		//--> 4!
		//원 순열 = n! / n
		
		
		
		
	}

}
