package day03;

public class Sample02 {

	public static void main(String[] args) {
		// 연산자 2
		
		//1) 증감
		int a = 10;
		int b = 7;
		int c = a++ + b +  ++a;
		//1. ++는 위치에 따라 연산 방식이 달라집니다.
		//ex a++일 경우에는 a에 대한 연산을 진행한 뒤 a의 값을 1 증가시킵니다.
		//   ++a일 경우에는 a의 값을 1 증가시킨 뒤 a에 대한 연산을 진행합니다.
		
		System.out.printf("a = %d  b = %d  c = %d\n", a,b,c);
		//a의 값은 몇인가? 1. 10 2. 11 3. 12   3(v)
		//b의 값은 몇인가? 1. 7  2. 8  3. 9    1(v)
		//c의 값은 몇인가? 1. 27 2. 28 3.29    3(v)
		
		
		//c의 계산 방식 1. a++ + b부터 계산됩니다.
		//10 + 7 = 17이 되고 a++에 의해 a가 10 -> 11로 변경됩니다.
		//2. 17 + ++a를 계산합니다.
		//   ++a에 의해 a가 11에서 12로 변경됩니다. 17 + 12 = 29
		
		//오답에 대한 해설
		//a를 10이라고 판단한 경우는 c에서 사용한 a++나 ++a가 그 계산 안에서만 변경된다라고 판단한 경우
		//이 경우 c의 값이 29라고 고르게 될 확률이 높음.
		
		//a를 11이라고 판단한 경우는 앞에있는 a++나 ++a를 해석을 잘못한 경우
		//이 경우 c의 값을 28이라고 고르는 경우가 많음.
		
		
		//2. 비트 연산
		//컴퓨터의 최소 단위(bit)로 연산을 하는 방식(컴퓨터와 같은 연산 방식)
		//따라서 연산 방식 중 가장 빠른 속도를 가지고 있습니다.
		//프로그램의 최적화 단계에서 많이 고려되는 연산 방식입니다.
		
		//1. 비트 연산 진행 방식 : 10진수를 2진수의 형태로 변경합니다.
		//2진수의 각 자리수는 2의 제곱 수입니다.
		//ex) 숫자 9의 경우 1 + 8로 구성됩니다.
		//따라서 1001로 표현됩니다.
		
		//연습: 숫자 34를 2진수로 표현하세요.
		//일반적으로 2진수를 계산하는 방법 -> 계속 2로 나눠서 나머지로 확인
		//   34 / 2 = 17 나머지 0
		//   17 / 2 =  8 나머지 1
		//   8  / 2 =  4 나머지 0
		//   4  / 2 =  2 나머지 0
		//   2  / 2 =  1 나머지 0
		//   1 (종료)
		//역순으로 배치 100010
		//2진수 쉽게 계산하는 방법
		//숫자를 2의 제곱수로 분리하는겁니다.
		//34 = 1 2 4 8 16 32 중에서 조합이 가능한 값만 확인
		//2하고 32를 고르면 34를 만들 수 있습니다.
		//골라지는 값을 1로 작성하고 아닌 값을 전부 0으로 작성합니다.
		//  0 1 0 0 0 1
		//역순 100010
		
		//1. AND 연산 (같은 위치의 비트가 1이면 1, 아니면 0으로 계산)
		int bit1 = 4;
		System.out.printf("4 & 1 = %d\n", bit1 & 1);
		//4    =  0100
		//1    =  0001
		//4 & 1 = 0000 => 0
		
		System.out.printf("4 & 2 = %d\n", bit1 & 2);
		System.out.printf("4 & 3 = %d\n", bit1 & 3);
		System.out.printf("4 & 4 = %d\n", bit1 & 4);
		System.out.printf("4 & 5 = %d\n", bit1 & 5);
		System.out.printf("4 & 6 = %d\n", bit1 & 6);
		System.out.printf("4 & 7 = %d\n", bit1 & 7);
		System.out.printf("4 & 8 = %d\n", bit1 & 8);
		
		//2. OR연산 (같은 위치의 비트 중 하나라도 1일 경우면 1로 계산 나머지는 0으로 계산)
		System.out.printf("4 | 1 = %d\n", bit1 | 1);
		System.out.printf("4 | 2 = %d\n", bit1 | 2);
		System.out.printf("4 | 3 = %d\n", bit1 | 3);
		System.out.printf("4 | 4 = %d\n", bit1 | 4);
		
		//3. XOR 연산 (Exclusive or) : 베타적 or 연산 , 베타적 논리합(XOR / EOR / EXOR -> 다 같은말이다.)
		//다르면 결합하고 같으면 버리시오.
		System.out.printf("4 ^ 1 = %d\n", bit1 ^ 1);
		System.out.printf("4 ^ 2 = %d\n", bit1 ^ 2);
		System.out.printf("4 ^ 3 = %d\n", bit1 ^ 3);
		System.out.printf("4 ^ 4 = %d\n", bit1 ^ 4);
		System.out.printf("4 ^ 5 = %d\n", bit1 ^ 5);
		//비트 연산의 팁: 2의 제곱수로 계산할 숫자를 분해해서 비교 분석으로 푼다.
		
		//4. 비트 반전
		//여기서 상위버전이 캐리, 오버플로우 2진수는 음수로 표현하기 어렵기 때문
		System.out.printf("bit1 = %d ~bit1 = %d\n", bit1, ~bit1);
		System.out.printf("10 = %d ~10 = %d\n", 10, ~10);
		
		//5. 쉬프트 연산
		//데이터에 비트를 왼쪽이나 오른쪽으로 이동시키는 연산
		//이동하면서 비어있는 자리는 0으로 채워지며, 갈 곳을 잃은 비트는 버려집니다.
		System.out.printf("1 << 1 = %d\n", 1 << 1);
		//1 => 0001
		//1 << 1 -> 0001을 왼쪽으로 한칸 민다.
		System.out.printf("1 << 2 = %d\n", 1 << 2);
		
		System.out.printf("1 << 5 = %d\n", 1 << 5);
		//5 => 0101
		//5 << 1
		//데이터 묶음을 한번에 이동시킵니다.
		//1010
		System.out.printf("1 >> 5 = %d\n", 1 >> 5);
		//5 => 0101
		//데이터 묶음을 오른쪽으로 한칸 이동시킵니다.
		// =>0010
		
		//시프트 연산의 의의는 데이터에 대한 이동에 있습니다.
		//비트 단위 조작, 수의 배수 증가/ 감소
		//일반적인 곱하기 나누기보다 빠른 방식
		
	}

}
